---
layout: post_study
title:  블록체인과 이더리움이란?
date: 2020-06-19 01:01:01
categories: blockchain
---
## 블록체인과 이더리움이란?
<br/><br/>
2017년말 한차례 광풍이 불었다. 모든 언론에서는 블록체인이 앞으로 4차 산업혁명시대의 선두주자로 모든 산업 기반을 바꿀 것이라며 이야기하였고, 비트코인은 매일 최고가를 갱신하며 2018년 1월에 1 비트코인이 2,660만원이라는 엄청난 금액으로 판매되었다. 모든 사람들이 너도나도 비트코인을 사지 않으면 시대에 뒤떨어지고 투자가치를 모르는 사람처럼 취급 받았고 블록체인을 하지 않는 기업은 뒤떨어질 것이라 많은 분석가들이 언론에서 이야기하였다. 그러나 아이러니하게도 2020년 6월 현재 비트코인의 가격은 1,100만원 선을 유지하고 있다.

![](/asset/study/blockchain/1/1.png)
[그림 1] 비트코인 시세 변동
{: .borderBox}
<br/><br/>
가상화폐를 부정적으로 보는 사람들의 공통된 논리는 최종 보증자가 없다는 것이다. 일반적으로 통용되는 화폐는 각 발행 국가 또는 기관이 최종적으로 회수하고 다른 재화로 변경할 수 있는 보증을 제공하고 있으나, 비트코인과 같은 가상화폐는 상장되어 있는 거래소(국내의 빗썸, 업비트 등)에서 다른 매수자에게 매도할 수 밖에 없기 때문에 화폐의 가치가 없다고 이야기하고 있다. 그러나 점차 가상화폐를 이용하여 실제 재화를 구매하고 서비스를 이용할 수 있게 됨으로써 어느정도 이러한 의심을 해결할 수 있으리라 기대하지만 완벽하게 화폐를 대체할 수는 없을지도 모른다.
<br/><br/>
블록체인을 설명하기 이전에 가상화폐를 먼저 설명하고 부정적인 이야기를 한 것은 적어도 개발자의 입장에서는 가상화폐의 투기적인 요소를 배제하고 블록체인이 가지고 있는 기술적인 특징과 이를 통해 좀더 좋은 서비스를 개발할 수 있도록 하자는 데 목적이 있다. 일반인이 생각하는 “블록체인 = 가상화폐”가 아닌 “블록체인을 유지하기 위한 수단인 가상화폐”라는 관점과 블록체인이 가지고 있는 기술적인 특징, 이더리움에서 추구하는 스마트 컨트렉트가 개발자로서 알아야 할 지식이라고 생각하며 앞으로 이러한 기술에 대해 알아보도록 하겠다.
<br/><br/>

### 1. 블록체인이란?
<br/><br/>

블록체인에 대한 언급은 1991년 스튜어트 하버(Stuart Haber)와 스캇 스토네타(W. Scott Stornetta)에 의해 처음 제안되고 1992년 머클 트리(Merkle Tree – 또는 해시트리라고 한다)라는 설계를 통해 각 문서간의 타임스탬프(timestamp)가 조작되지 않도록 하는 제안을 하였다. 이후 2008년도에 사토시 나카모토(Satoshi Nakamoto)라고 알려진 인물로부터 블록체인(blockchain)이라는 개념이 논문으로 발표되었다. 초기 논문에서는 블록(block)과 체인(chain)이 분리된 개념으로 설명되었으며 2016년도경에 하나의 단어인 블록체인(blockchain)이라는 용어로 통용되기 시작하였다.
<br/><br/>
블록 체인은 블록(Block)과 체인(Chain)의 합성어로 블록들이 사슬로 연결되어 있다는 의미를 가지고 있다. 블록은 데이터들을 포함하는 하나의 덩어리이고 이 덩어리들이 서로 연결되어 있다고 생각하면 된다. 이때 초기에 생성된 블록을 제네시스 블록(genesis block)이라고 하며, 그 다음에 생성되는 블록들은 자기 이전 블록에 대한 정보(해쉬값)를 가지고 있어 서로 연결되었다는 의미의 체인(chain)으로 설명된다.
<br/><br/>
현재의 전산 시스템은 몇 대의 서버를 중심으로 여러 사용자가 접속하여 데이터를 입력하고, 처리하며 처리된 결과를 데이터베이스에 저장하고 관리하는 형태로 구성되어 있다. 중앙 집중화된 시스템 구조는 유지관리 편의성은 존재할지 모르겠지만 대용량의 서버와 관리 인력, 그리고 데이터 해킹 및 유실에 따른 위험성이 존재한다. 만약, 거래하는 은행의 계좌정보가 해커에 의해 탈취되어 잔고가 0으로 변경되거나 시스템이 갑자기 파손되어 데이터를 복구할 수 없는 경우가 발생한다면 엄청난 손실이 발생할 것이다. 이런 문제를 해결하기 위하여 중앙 집중화된 서비스는 각종 보안 솔루션과 중복된 메인 프레임을 통해 데이터를 관리하고 이중, 삼중으로 데이터를 백업하여 재난에 대비하고 있다.
<br/><br/>

![](/asset/study/blockchain/1/2.png)
[그림 2] 중앙 집중형 서비스와 분산형 서비스
{: .borderBox}
<br/><br/>
이런 중앙 집중적인 데이터의 문제점을 해결하고자 여러 곳에 동일한 데이터를 분산하여 저장하고(복사본을 여러 곳에 저장) 관리의 주체 또한 중앙 집중적인 관리 단체(은행 등)가 아닌 개인에게 분산하여 어떠한 실력자가 시스템의 통제를 하지 못하도록 하는 방식을 실현한 것이 블록체인이다.
<br/><br/>
분산 서비스로 구성된 시스템에서는 특정 서버(블록체인에서는 노드라고 한다)의 이상이 발생하는 경우 다른 노드들은 정확한 값을 가지고 있으므로 새로 복제하거나 잘못된 노드를 전체 네트워크에서 제외함으로써 일관성을 유지할 수 있는 장점을 가지고 있다.
<br/><br/>
분산서비스의 경우 모든 노드들이 동일한 원장을 가지고 있으므로 시스템의 오류 등에 강한 장점을 가지고 있지만 각각 일어나는 거래에 대해서는 단일 시점에 한곳에서 발생하게 되므로 위조 또는 변조가 가능하다. 이러한 문제점을 해결하기 위하여 블록체인에서는 암호학의 ‘디지털 서명(Digital Sign)’ 기술의 도움을 받아 해결하고 있다.
<br/><br/>

![](/asset/study/blockchain/1/3.png)
[그림 3] 공개키 – 개인키 디지털 서명 (https://commons.wikimedia.org/wiki/File:Digital_Signature_diagram.svg)
{: .borderBox}
<br/><br/>
발생한 트랜젝션은 자신의 개인키를 이용하여 송신하고 수신측에서는 송신자의 공개키를 이용하여 복호화 한 후 데이터의 정합성을 확인하는 디지털 서명 방식은 생성한 트랜젝션이 안전하게 원장에 기록될 수 있는 기술적인 근거를 제공해 준다. 이제 블록체인을 구성하는 블록과 체인을 연결하는 방법에 대해 알아보도록 하자.
<br/><br/>
#### 1.1 블록(Block)
<br/><br/>
데이터들을 포함하고 있는 블록은 헤더(Header)와 거래 내역(Tx: Transaction)들로 구성된다. 헤더에는 일반적으로 다음과 같은 내용이 포함된다(아래 표의 설명은 비트코인을 기준으로 설명하였다).
<br/><br/>
|필드명|크기(byte)|설명|
|------|---|---|
|Version|4|버전 정보|
|Previous Block Hash|32|이전 블록 헤더의 해쉬 값|
|Merkle Root|32|블록내 트랜젝션들의 머클 트리의 루트에 대한 해쉬 값|
|Timestamp|4|UNIX 시간 형식으로 표현되는 블록이 생성된 시간|
|Difficulty Target|4|블록의 난이도 목표 값|
|Nonce|4|채굴자가 올바른 해쉬값을 찾을때 까지의 회수|
<br/><br/>
헤더 정보중 이전 블록 헤더의 해쉬값을 이용하여 서로의 체인을 구성하게 되므로 각각의 블록을 찾기 위해서 헤더는 매우 중요한 역할을 한다. 각각의 해쉬 값은 SHA256 해쉬 함수를 이용하여 계산되는 32바이트의 값이다.
<br/><br/>

![](/asset/study/blockchain/1/4.png)
[그림 4] 블록체인의 기본적인 구조
{: .borderBox}
<br/><br/>
[그림 4]에서 해쉬값이 계산되는 방식에 대해 좀더 자세히 알아보도록 하자. 거래 A가 발생하면 이 거래정보에 대한 해쉬값 Hash(A)를 계산한다. 만약 거래 A에 대한 내역이 변경된다면 해쉬값 A도 변경되게 될 것이다. 그리고 거래 B에 대한 해쉬값 Hash(B)을 계산한 후 이 두 해쉬값에 대한 해쉬 값 Hash(Hash(A), Hash(B))을 계산한다. 이렇게 만들어진 머클트리의 루트에 대한 해쉬 값을 계산하여 머클트리 루트에 기록한다. 이로써 개별 거래들에 대한 모든 정보는 하나의 대표적인 머클트리 루트의 해쉬 값으로 연결되게 되고, 하위 노드의 값이 변경되게 되는 경우 해쉬값이 일치하지 않게 되어 위조 및 변조에 대한 적발이 가능해 진다.
<br/><br/>
블록헤더에 필요한 머클트리 루트 해쉬값과 소프트웨어 버전, 이전 블록의 해쉬값, 타임스탬프 및 블록의 난이도 목표값은 계산이 완료되고 Nonce의 값만이 계산되면 이 값들을 이용하여 블록에 대한 대표 해쉬값을 계산할 수 있게 된다. 대표 해쉬값이 계산되면 하나의 블록은 완성된 것이라고 판단할 수 있으며, Nonce를 계산하여 하나의 블록에 대한 블록 해쉬를 구하는 과정을 ‘작업증명(Proof or Work)’이라고 하며 다른 말로는 ‘채굴(Mining)’이라고 한다.
<br/>
<br/>
#### 1.2 체인(Chain)의 구성 및 역할
<br/><br/>
블록 체인은 블록들이 연결(Chain)되어 구성된다고 이야기하였다. 이를 위해서는 이전의 정보를 찾기 위한 정보가 필요하며 이를 위해 이전 블록의 해쉬값을 현재 블록의 헤더에 [그림 5]와 같이 저장한다.
<br/><br/>

![](/asset/study/blockchain/1/5.png)
[그림 5] 블록 체인의 구성
{: .borderBox}
<br/><br/>
즉, 블록체인은 하나의 링크드 리스트(Linked List)와 같은 형식으로 되어 있다.
<br/><br/>
#### 1.3. Nonce 값의 계산 - 작업 증명(POW: Proof Of Work)
앞에서 블록 헤더에 대한 해쉬값을 구하기 위해서는 Nonce에 해당하는 값을 계산하는 과정이 필요하다고 언급하였다. ‘채굴’ 또는 ‘작업증명’이라는 과정은 Nonce의 값을 변화시키면서 해당 블록이 요구하는 해쉬값 보다 작은 해쉬값이 나오도록 하는 반복 과정이다.
<br/><br/>
![](/asset/study/blockchain/1/6.png)
[그림 6] 블록 해쉬값 계산: Nonce의 조정
{: .borderBox}
<br/><br/>
[그림 6]에서 Nonce를 제외한 나머지 값들은 블록 해쉬를 계산하기 전에 이미 상수로 고정되며, Nonce의 값만이 변수로 입력된다. 목표 해쉬값인 ‘0x0000001A’보다 작은 값이 나올 때까지 임의의 값을 Nonce에 주면서 계산을 해 보니 Nonce의 값이 9가 되었을 때 목표 해쉬값보다 작게 되었다고 가정해 보자. 이런 경우 작업 증명이 완료되었다고 하며, Nonce의 값을 9로 하여 블록 헤더에 대한 해쉬값을 계산하게 된다. 이 때 적합한 Nonce를 찾은 사람은 채굴(Mining)의 보상을 받게 설계되어 있다.
<br/><br/>
실제 이러한 계산은 상당히 많은 계산량을 필요로 하기 때문에 그래픽카드나 전용 기계를 사용하는 채굴자와 마이닝 풀(여러 명이 동맹을 맺어 자신에게 주어진 범위의 Nonce값을 입력하여 계산하고, 작업증명이 되면 풀에 있는 사용자들이 보상을 나눠 가지는 형태)이 등장한 것이다.
<br/><br/>
#### 1.4. 블록체인의 위변조 방지
<br/><br/>
![](/asset/study/blockchain/1/6.png)
[그림 7] 거래 데이터 변경에 따른 해쉬값 변경
{: .borderBox}
<br/><br/>
블록 내부와 연결 사이에는 연산량이 많은 해쉬 함수를 이용한다. 연산량이 많은 해쉬값을 이용하여 리스트를 구성하는 이유는 거래 정보등이 변조되는 경우를 막기 위해서이다. [그림 7]의 ‘블록 #1’의 거래 중 ‘Tx0(김영희 -> 박나래 100BTC)’의 거래를 ‘Tx0(김영희 -> 박나래 1BTC)’로 누군가 변경하였다고 가정해 보자. 이 경우 일단 ‘블록 #1’의 머클 루트에 해당하는 값이 변경되어야 한다. 또한 이 값의 변경으로 인해 ‘블록 #1’의 블록 해쉬값이 변경되어야 한다(이때는 작업 증명이 필요할 정도로 많은 계산이 필요하다). 이후 ‘블록 #2’의 ‘Previous Hash Block’의 값이 변경되어야 하며, 그 뒤에 모든 블록의 값들이 전부 새로 계산되어야 하는 것이다. 이 과정을 통해 블록의 위변조에 대한 안전성을 보장할 수 있다.
<br/><br/>

#### 1.5 거래내역의 전파 및 충돌해소
<br/><br/>
블록체인은 동일한 원장을 모든 노드들이 동일하게 유지하고 관리한다. 새로운 거래가 생성되면 거래의 내용은 블록체인 네트워크 상의 한 노드에 전송되게 된다. 거래 정보를 받은 노드는 이 거래가 정확한지 검증한 후 블록의 거래내역에 추가하고 거래 정보를 다른 인접한 노드로 전달한다. 이 거래 전파의 과정이 전 노드에 대해 확산되면 하나의 거래 정보가 동일하게 유지되게 되는 것이다. 블록의 거래가 일정량만큼 채워지게 되면 블록을 생성한다. 거래 내역의 전파는 다음과 같은 순서로 이루어 진다.
<br/><br/>
1)	거래 내역의 확인
<br/>
어떤 거래가 발생하면 해당 정보는 가장 인접한 노드로 전달된다. 거래 정보를 수신한 노드는 해당 거래의 디지털 서명이 정상적인지, 거래 내용이(예를 들어 비트코인을 전송한다면 보내는 사람의 계좌에 정상적으로 송금액 이상의 비트코인이 있는지 여부) 정상적인지등을 확인한다. 만약 비정상적인 거래정보인 경우에는 해당 노드에서 바로 폐기시켜 버리고 정상인 경우에는 해당 정보를 자신 노드의 메모리영역에 저장하고 주변 노드로 거래 내역을 전송한다.
<br/><br/>
일반적으로 하나의 노드는 주변의 8개 정도의 노드와 연결되어 있으며, 각각의 노드는 수신받은 거래 정보를 검증하고 자신의 메모리에 저장한다.
<br/><br/>
2)	채굴의 진행
<br/>
메모리 영역에 어느 정도의 데이터(약 1Mbyte)가 쌓이게 되면 새로운 블록을 생성하기 위하여 앞에서 설명한 Nonce값을 변경시켜 가면서 채굴이 발생하게 된다. 이 때 거래의 내역은 메모리상에 도달한 순서가 아니라 채굴 보상을 위하여 제시한 금액(채굴자에게 돌아가는 보상 금액)이 높은 순으로 블록에 추가하는 작업을 하게 된다.
<br/><br/>
노드에서 해당 블록의 목표 해쉬값보다 작은 Nonce를 구하게 되면 완성된 블록을 주변 노드에 전송하게 된다. 이 때 다른 노드들도 자신의 블록을 생성하기 위하여 열심히 채굴을 하고 있는 상태이다. 만약 다른 노드가 채굴중에 해당 블록에 대한 정보를 수신하게 되면 채굴을 포기하고 해당 블록을 자신의 블록체인에 추가한 후 다른 노드로 블록정보를 전송한다.
<br/><br/>
3)	블록체인의 충돌 검토
<br/>
정상적인 거래의 전파라면 앞의 두 과정만으로 모든 노드들의 블록체인 정보가 업데이트 될 것이다. 그렇지만 실질적으로는 새로운 블록을 만들기 위하여 모든 노드들이 경쟁을 하면서 거의 동시에 두개의 블록이 생성될 수 있는 가능성이 존재하게 된다.
<br/><br/>
![](/asset/study/blockchain/1/8.png)
[그림 8] 생성된 블록(#4)의 충돌
{: .borderBox}
<br/><br/>
[그림 8]에서 A노드와 H노드가 거의 동시에 4번 블록을 생성했다고 가정해 보자. 각자 생성한 블록은 블록체인에 등록한 후 블록을 인접한 노드로 전달하기 시작한다. A노드에서 생성한 블록은 B, C, D 노드로 전파되고, H노드에서 생성한 블록은 F, G, E로 전파된다. D노드는 수신 받은 블록을 E 노드로 전파하고, E노드는 D노드로 블록을 전파하게 된다. 이 때 각자의 노드는 이미 4번 블록을 블록체인에 가지고 있으므로 자신의 블록체인을 업데이트 하지 않고 수신한 블록을 버려 버리게 된다.
<br/><br/>
위의 상황의 경우 A, B, C, D 노드가 가지고 있는 블록체인과 E, F, G, H 노드가 가지고 있는 불록체인 데이터가 상이하게 되는 현상이 발생한다. 이후 [그림 9]와 같이 새로운 블록이 B 노드에서 생성된다고 가정하자.
<br/><br/>
![](/asset/study/blockchain/1/9.png)
[그림 9] 새로운 블록(#5)의 생성과 전파
{: .borderBox}
<br/><br/>
B의 노드에서 발생한 5번 블록은 인접한 노드로 블록을 전달하게 된다. 이 때 A, C, D 노드의 경우에는 5번 블록의 이전블록 해쉬값이 일치하므로 단순하게 블록체인에 블록을 추가한다. 그러나 E, F, G, H의 경우에는 5번 블록이 가지고 있는 이전 블록의 해쉬값이 불일치 하므로 기존에 유지하던 체인을 2차 체인으로 만든 후 A쪽에서 생성했던 4번 블록과 수신한 5번 블록을 받아 체인을 구성하게 된다. 이때 [그림 10]과 같이 하늘색의 블록은 고아 블록(Orphan Block)이라고 한다.
<br/><br/>
![](/asset/study/blockchain/1/10.png)
[그림 10] 고아(Orphan) 블록의 생성
{: .borderBox}
<br/><br/>
5번 블록으로 인해 고아 블록이 생기게 되는 현상을 “분기가 발생”했다고 하며 분기가 발생하는 경우 메인 체인을 선택하는 것은 작업 증명을 가장 많이 한 체인(블록의 길이가 가장 긴 체인)으로 선택한다.
<br/><br/>
### 2. 이더리움
<br/><br/>
이더리움은 2013년 비탈릭 부테린(Vitalik Buterin)이 제안한 후 2015년 7월 세상에 공표한 블록체인 기반의 암호화폐 플랫폼이다(현재도 계속 개발 중이다). 비트코인으로 대표되는 블록체인은 거래 내역을 여러 노드에 동일하게 분산하여 관리하는 것을 기본으로 하고 있지만 비탈릭의 경우에는 단순한 화폐 원장의 기능과 더불어 솔리디티(Solidity)라는 프로그래밍 언어를 통하여 자동으로 실행되는 스마트 컨트랙트(Smart Contract)를 개발할 수 있는 환경을 제공하였다. 이 스마트 컨트랙트를 이용하여 계약서, 공증, 전자 투표 등의 다양한 서비스를 개발하고, 정보를 블록체인 내부에 저장할 수 있는 분산 네트워크 플랫폼이다.
<br/><br/>

#### 2.1 스마트 컨트랙트
<br/><br/>
스마트 컨트랙트는 블록체인 상에서 계약의 당사자들 상호간에 합의된 규칙에 따라 진행될 수 있도록 구현된 소프트웨어이다. 사전에 정의된 규칙에 만족하는 상황이 발생하면 지정해 놓은 계약은 자동적으로 처리되고 모든 처리된 거래 내역은 블록체인상에 기록되어 안전한 거래를 보장한다.
<br/><br/>
현실세계에서는 일반적으로 A와 B의 거래에 있어서 서로 상호 신뢰를 목적으로 계약서를 작성한다. 또한 계약서를 확인하기 위하여 제 삼자(공증이나 거래 중계인 등)가 개입하는 경우가 일반적이다. 이 과정에서 우리는 상당한 수수료를 지불해야 한다. 이제 자동차 계약을 예로 한번 알아보자.
<br/><br/>
![](/asset/study/blockchain/1/11.png)
[그림 11] 고전적 차량 계약
{: .borderBox}
<br/><br/>