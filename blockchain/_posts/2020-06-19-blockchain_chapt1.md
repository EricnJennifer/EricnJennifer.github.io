---
layout: post_study
title:  블록체인과 이더리움이란?
date: 2020-06-19 01:01:01
categories: blockchain
---
## 블록체인과 이더리움이란?
<br/><br/>
2017년말 한차례 광풍이 불었다. 모든 언론에서는 블록체인이 앞으로 4차 산업혁명시대의 선두주자로 모든 산업 기반을 바꿀 것이라며 이야기하였고, 비트코인은 매일 최고가를 갱신하며 2018년 1월에 1 비트코인이 2,660만원이라는 엄청난 금액으로 판매되었다. 모든 사람들이 너도나도 비트코인을 사지 않으면 시대에 뒤떨어지고 투자가치를 모르는 사람처럼 취급 받았고 블록체인을 하지 않는 기업은 뒤떨어질 것이라 많은 분석가들이 언론에서 이야기하였다. 그러나 아이러니하게도 2020년 6월 현재 비트코인의 가격은 1,100만원 선을 유지하고 있다.
<br/><br/>

![](/asset/study/blockchain/1/1.png)
[그림 1] 비트코인 시세 변동
{: .borderBox}

<br/>
가상화폐를 부정적으로 보는 사람들의 공통된 논리는 최종 보증자가 없다는 것이다. 일반적으로 통용되는 화폐는 각 발행 국가 또는 기관이 최종적으로 회수하고 다른 재화로 변경할 수 있는 보증을 제공하고 있으나, 비트코인과 같은 가상화폐는 상장되어 있는 거래소(국내의 빗썸, 업비트 등)에서 다른 매수자에게 매도할 수 밖에 없기 때문에 화폐의 가치가 없다고 이야기하고 있다. 그러나 점차 가상화폐를 이용하여 실제 재화를 구매하고 서비스를 이용할 수 있게 됨으로써 어느정도 이러한 의심을 해결할 수 있으리라 기대하지만 완벽하게 화폐를 대체할 수는 없을지도 모른다.
<br/><br/>
블록체인을 설명하기 이전에 가상화폐를 먼저 설명하고 부정적인 이야기를 한 것은 적어도 개발자의 입장에서는 가상화폐의 투기적인 요소를 배제하고 블록체인이 가지고 있는 기술적인 특징과 이를 통해 좀더 좋은 서비스를 개발할 수 있도록 하자는 데 목적이 있다. 일반인이 생각하는 “블록체인 = 가상화폐”가 아닌 “블록체인을 유지하기 위한 수단인 가상화폐”라는 관점과 블록체인이 가지고 있는 기술적인 특징, 이더리움에서 추구하는 스마트 컨트렉트가 개발자로서 알아야 할 지식이라고 생각하며 앞으로 이러한 기술에 대해 알아보도록 하겠다.
<br/><br/>

### 1. 블록체인이란?
<br/>
블록체인에 대한 언급은 1991년 스튜어트 하버(Stuart Haber)와 스캇 스토네타(W. Scott Stornetta)에 의해 처음 제안되고 1992년 머클 트리(Merkle Tree – 또는 해시트리라고 한다)라는 설계를 통해 각 문서간의 타임스탬프(timestamp)가 조작되지 않도록 하는 제안을 하였다. 이후 2008년도에 사토시 나카모토(Satoshi Nakamoto)라고 알려진 인물로부터 블록체인(blockchain)이라는 개념이 논문으로 발표되었다. 초기 논문에서는 블록(block)과 체인(chain)이 분리된 개념으로 설명되었으며 2016년도경에 하나의 단어인 블록체인(blockchain)이라는 용어로 통용되기 시작하였다.
<br/><br/>
블록 체인은 블록(Block)과 체인(Chain)의 합성어로 블록들이 사슬로 연결되어 있다는 의미를 가지고 있다. 블록은 데이터들을 포함하는 하나의 덩어리이고 이 덩어리들이 서로 연결되어 있다고 생각하면 된다. 이때 초기에 생성된 블록을 제네시스 블록(genesis block)이라고 하며, 그 다음에 생성되는 블록들은 자기 이전 블록에 대한 정보(해쉬값)를 가지고 있어 서로 연결되었다는 의미의 체인(chain)으로 설명된다.
<br/><br/>
현재의 전산 시스템은 몇 대의 서버를 중심으로 여러 사용자가 접속하여 데이터를 입력하고, 처리하며 처리된 결과를 데이터베이스에 저장하고 관리하는 형태로 구성되어 있다. 중앙 집중화된 시스템 구조는 유지관리 편의성은 존재할지 모르겠지만 대용량의 서버와 관리 인력, 그리고 데이터 해킹 및 유실에 따른 위험성이 존재한다. 만약, 거래하는 은행의 계좌정보가 해커에 의해 탈취되어 잔고가 0으로 변경되거나 시스템이 갑자기 파손되어 데이터를 복구할 수 없는 경우가 발생한다면 엄청난 손실이 발생할 것이다. 이런 문제를 해결하기 위하여 중앙 집중화된 서비스는 각종 보안 솔루션과 중복된 메인 프레임을 통해 데이터를 관리하고 이중, 삼중으로 데이터를 백업하여 재난에 대비하고 있다.
<br/><br/>

![](/asset/study/blockchain/1/2.png)
[그림 2] 중앙 집중형 서비스와 분산형 서비스
{: .borderBox}

<br/>
이런 중앙 집중적인 데이터의 문제점을 해결하고자 여러 곳에 동일한 데이터를 분산하여 저장하고(복사본을 여러 곳에 저장) 관리의 주체 또한 중앙 집중적인 관리 단체(은행 등)가 아닌 개인에게 분산하여 어떠한 실력자가 시스템의 통제를 하지 못하도록 하는 방식을 실현한 것이 블록체인이다.
<br/><br/>
분산 서비스로 구성된 시스템에서는 특정 서버(블록체인에서는 노드라고 한다)의 이상이 발생하는 경우 다른 노드들은 정확한 값을 가지고 있으므로 새로 복제하거나 잘못된 노드를 전체 네트워크에서 제외함으로써 일관성을 유지할 수 있는 장점을 가지고 있다.
<br/><br/>
분산서비스의 경우 모든 노드들이 동일한 원장을 가지고 있으므로 시스템의 오류 등에 강한 장점을 가지고 있지만 각각 일어나는 거래에 대해서는 단일 시점에 한곳에서 발생하게 되므로 위조 또는 변조가 가능하다. 이러한 문제점을 해결하기 위하여 블록체인에서는 암호학의 ‘디지털 서명(Digital Sign)’ 기술의 도움을 받아 해결하고 있다.
<br/><br/>

![](/asset/study/blockchain/1/3.png)
[그림 3] 공개키 – 개인키 디지털 서명 (https://commons.wikimedia.org/wiki/File:Digital_Signature_diagram.svg)
{: .borderBox}

<br/>
발생한 트랜젝션은 자신의 개인키를 이용하여 송신하고 수신측에서는 송신자의 공개키를 이용하여 복호화 한 후 데이터의 정합성을 확인하는 디지털 서명 방식은 생성한 트랜젝션이 안전하게 원장에 기록될 수 있는 기술적인 근거를 제공해 준다. 이제 블록체인을 구성하는 블록과 체인을 연결하는 방법에 대해 알아보도록 하자.
<br/><br/>
<br/><br/>

#### 1.1 블록(Block)
<br/>
데이터들을 포함하고 있는 블록은 헤더(Header)와 거래 내역(Tx: Transaction)들로 구성된다. 헤더에는 일반적으로 다음과 같은 내용이 포함된다(아래 표의 설명은 비트코인을 기준으로 설명하였다).
<br/><br/>

|<center>필드명</center>|<center>크기(byte)</center>|<center>설명</center>|
|------|------|------|
| Version | 4 | 버전 정보 |
| Previous Block Hash | 32 | 이전 블록 헤더의 해쉬 값 |
| Merkle Root | 32 | 블록내 트랜젝션들의 머클 트리의 루트에 대한 해쉬 값 |
| Timestamp | 4 | UNIX 시간 형식으로 표현되는 블록이 생성된 시간 |
| Difficulty Target | 4 | 블록의 난이도 목표 값 |
| Nonce | 4 | 채굴자가 올바른 해쉬값을 찾을때 까지의 회수 |
{: .table table-striped}

<br/>
헤더 정보중 이전 블록 헤더의 해쉬값을 이용하여 서로의 체인을 구성하게 되므로 각각의 블록을 찾기 위해서 헤더는 매우 중요한 역할을 한다. 각각의 해쉬 값은 SHA256 해쉬 함수를 이용하여 계산되는 32바이트의 값이다.
<br/><br/>

![](/asset/study/blockchain/1/4.png)
<br>[그림 4] 블록체인의 기본적인 구조
{: .borderBox}

<br/>
[그림 4]에서 해쉬값이 계산되는 방식에 대해 좀더 자세히 알아보도록 하자. 거래 A가 발생하면 이 거래정보에 대한 해쉬값 Hash(A)를 계산한다. 만약 거래 A에 대한 내역이 변경된다면 해쉬값 A도 변경되게 될 것이다. 그리고 거래 B에 대한 해쉬값 Hash(B)을 계산한 후 이 두 해쉬값에 대한 해쉬 값 Hash(Hash(A), Hash(B))을 계산한다. 이렇게 만들어진 머클트리의 루트에 대한 해쉬 값을 계산하여 머클트리 루트에 기록한다. 이로써 개별 거래들에 대한 모든 정보는 하나의 대표적인 머클트리 루트의 해쉬 값으로 연결되게 되고, 하위 노드의 값이 변경되게 되는 경우 해쉬값이 일치하지 않게 되어 위조 및 변조에 대한 적발이 가능해 진다.
<br/><br/>
블록헤더에 필요한 머클트리 루트 해쉬값과 소프트웨어 버전, 이전 블록의 해쉬값, 타임스탬프 및 블록의 난이도 목표값은 계산이 완료되고 Nonce의 값만이 계산되면 이 값들을 이용하여 블록에 대한 대표 해쉬값을 계산할 수 있게 된다. 대표 해쉬값이 계산되면 하나의 블록은 완성된 것이라고 판단할 수 있으며, Nonce를 계산하여 하나의 블록에 대한 블록 해쉬를 구하는 과정을 ‘작업증명(Proof or Work)’이라고 하며 다른 말로는 ‘채굴(Mining)’이라고 한다.
<br/><br/>

#### 1.2 체인(Chain)의 구성 및 역할
<br/>
블록 체인은 블록들이 연결(Chain)되어 구성된다고 이야기하였다. 이를 위해서는 이전의 정보를 찾기 위한 정보가 필요하며 이를 위해 이전 블록의 해쉬값을 현재 블록의 헤더에 [그림 5]와 같이 저장한다.
<br/><br/>

![](/asset/study/blockchain/1/5.png)
[그림 5] 블록 체인의 구성
{: .borderBox}

<br/>
즉, 블록체인은 하나의 링크드 리스트(Linked List)와 같은 형식으로 되어 있다.
<br/><br/>

#### 1.3 Nonce 값의 계산 - 작업 증명(POW: Proof Of Work)
<br/>
앞에서 블록 헤더에 대한 해쉬값을 구하기 위해서는 Nonce에 해당하는 값을 계산하는 과정이 필요하다고 언급하였다. ‘채굴’ 또는 ‘작업증명’이라는 과정은 Nonce의 값을 변화시키면서 해당 블록이 요구하는 해쉬값 보다 작은 해쉬값이 나오도록 하는 반복 과정이다.
<br/><br/>

![](/asset/study/blockchain/1/6.png)
[그림 6] 블록 해쉬값 계산: Nonce의 조정
{: .borderBox}

<br/>
[그림 6]에서 Nonce를 제외한 나머지 값들은 블록 해쉬를 계산하기 전에 이미 상수로 고정되며, Nonce의 값만이 변수로 입력된다. 목표 해쉬값인 ‘0x0000001A’보다 작은 값이 나올 때까지 임의의 값을 Nonce에 주면서 계산을 해 보니 Nonce의 값이 9가 되었을 때 목표 해쉬값보다 작게 되었다고 가정해 보자. 이런 경우 작업 증명이 완료되었다고 하며, Nonce의 값을 9로 하여 블록 헤더에 대한 해쉬값을 계산하게 된다. 이 때 적합한 Nonce를 찾은 사람은 채굴(Mining)의 보상을 받게 설계되어 있다.
<br/><br/>
실제 이러한 계산은 상당히 많은 계산량을 필요로 하기 때문에 그래픽카드나 전용 기계를 사용하는 채굴자와 마이닝 풀(여러 명이 동맹을 맺어 자신에게 주어진 범위의 Nonce값을 입력하여 계산하고, 작업증명이 되면 풀에 있는 사용자들이 보상을 나눠 가지는 형태)이 등장한 것이다.
<br/><br/>

#### 1.4. 블록체인의 위변조 방지
<br/>

![](/asset/study/blockchain/1/6.png)
[그림 7] 거래 데이터 변경에 따른 해쉬값 변경
{: .borderBox}

<br/>
블록 내부와 연결 사이에는 연산량이 많은 해쉬 함수를 이용한다. 연산량이 많은 해쉬값을 이용하여 리스트를 구성하는 이유는 거래 정보등이 변조되는 경우를 막기 위해서이다. [그림 7]의 ‘블록 #1’의 거래 중 ‘Tx0(김영희 -> 박나래 100BTC)’의 거래를 ‘Tx0(김영희 -> 박나래 1BTC)’로 누군가 변경하였다고 가정해 보자. 이 경우 일단 ‘블록 #1’의 머클 루트에 해당하는 값이 변경되어야 한다. 또한 이 값의 변경으로 인해 ‘블록 #1’의 블록 해쉬값이 변경되어야 한다(이때는 작업 증명이 필요할 정도로 많은 계산이 필요하다). 이후 ‘블록 #2’의 ‘Previous Hash Block’의 값이 변경되어야 하며, 그 뒤에 모든 블록의 값들이 전부 새로 계산되어야 하는 것이다. 이 과정을 통해 블록의 위변조에 대한 안전성을 보장할 수 있다.
<br/><br/>

#### 1.5 거래내역의 전파 및 충돌해소
<br/><br/>
블록체인은 동일한 원장을 모든 노드들이 동일하게 유지하고 관리한다. 새로운 거래가 생성되면 거래의 내용은 블록체인 네트워크 상의 한 노드에 전송되게 된다. 거래 정보를 받은 노드는 이 거래가 정확한지 검증한 후 블록의 거래내역에 추가하고 거래 정보를 다른 인접한 노드로 전달한다. 이 거래 전파의 과정이 전 노드에 대해 확산되면 하나의 거래 정보가 동일하게 유지되게 되는 것이다. 블록의 거래가 일정량만큼 채워지게 되면 블록을 생성한다. 거래 내역의 전파는 다음과 같은 순서로 이루어 진다.
<br/><br/>
    >1)	거래 내역의 확인
<br/>
어떤 거래가 발생하면 해당 정보는 가장 인접한 노드로 전달된다. 거래 정보를 수신한 노드는 해당 거래의 디지털 서명이 정상적인지, 거래 내용이(예를 들어 비트코인을 전송한다면 보내는 사람의 계좌에 정상적으로 송금액 이상의 비트코인이 있는지 여부) 정상적인지등을 확인한다. 만약 비정상적인 거래정보인 경우에는 해당 노드에서 바로 폐기시켜 버리고 정상인 경우에는 해당 정보를 자신 노드의 메모리영역에 저장하고 주변 노드로 거래 내역을 전송한다.
<br/><br/>
일반적으로 하나의 노드는 주변의 8개 정도의 노드와 연결되어 있으며, 각각의 노드는 수신받은 거래 정보를 검증하고 자신의 메모리에 저장한다.
<br/><br/>
2)	채굴의 진행
<br/>
메모리 영역에 어느 정도의 데이터(약 1Mbyte)가 쌓이게 되면 새로운 블록을 생성하기 위하여 앞에서 설명한 Nonce값을 변경시켜 가면서 채굴이 발생하게 된다. 이 때 거래의 내역은 메모리상에 도달한 순서가 아니라 채굴 보상을 위하여 제시한 금액(채굴자에게 돌아가는 보상 금액)이 높은 순으로 블록에 추가하는 작업을 하게 된다.
<br/><br/>
노드에서 해당 블록의 목표 해쉬값보다 작은 Nonce를 구하게 되면 완성된 블록을 주변 노드에 전송하게 된다. 이 때 다른 노드들도 자신의 블록을 생성하기 위하여 열심히 채굴을 하고 있는 상태이다. 만약 다른 노드가 채굴중에 해당 블록에 대한 정보를 수신하게 되면 채굴을 포기하고 해당 블록을 자신의 블록체인에 추가한 후 다른 노드로 블록정보를 전송한다.
<br/><br/>
3)	블록체인의 충돌 검토
<br/>
정상적인 거래의 전파라면 앞의 두 과정만으로 모든 노드들의 블록체인 정보가 업데이트 될 것이다. 그렇지만 실질적으로는 새로운 블록을 만들기 위하여 모든 노드들이 경쟁을 하면서 거의 동시에 두개의 블록이 생성될 수 있는 가능성이 존재하게 된다.
<br/><br/>

![](/asset/study/blockchain/1/8.png)
[그림 8] 생성된 블록(#4)의 충돌
{: .borderBox}

<br/>
[그림 8]에서 A노드와 H노드가 거의 동시에 4번 블록을 생성했다고 가정해 보자. 각자 생성한 블록은 블록체인에 등록한 후 블록을 인접한 노드로 전달하기 시작한다. A노드에서 생성한 블록은 B, C, D 노드로 전파되고, H노드에서 생성한 블록은 F, G, E로 전파된다. D노드는 수신 받은 블록을 E 노드로 전파하고, E노드는 D노드로 블록을 전파하게 된다. 이 때 각자의 노드는 이미 4번 블록을 블록체인에 가지고 있으므로 자신의 블록체인을 업데이트 하지 않고 수신한 블록을 버려 버리게 된다.
<br/><br/>
위의 상황의 경우 A, B, C, D 노드가 가지고 있는 블록체인과 E, F, G, H 노드가 가지고 있는 불록체인 데이터가 상이하게 되는 현상이 발생한다. 이후 [그림 9]와 같이 새로운 블록이 B 노드에서 생성된다고 가정하자.
<br/><br/>

![](/asset/study/blockchain/1/9.png)
[그림 9] 새로운 블록(#5)의 생성과 전파
{: .borderBox}

<br/>
B의 노드에서 발생한 5번 블록은 인접한 노드로 블록을 전달하게 된다. 이 때 A, C, D 노드의 경우에는 5번 블록의 이전블록 해쉬값이 일치하므로 단순하게 블록체인에 블록을 추가한다. 그러나 E, F, G, H의 경우에는 5번 블록이 가지고 있는 이전 블록의 해쉬값이 불일치 하므로 기존에 유지하던 체인을 2차 체인으로 만든 후 A쪽에서 생성했던 4번 블록과 수신한 5번 블록을 받아 체인을 구성하게 된다. 이때 [그림 10]과 같이 하늘색의 블록은 고아 블록(Orphan Block)이라고 한다.
<br/><br/>

![](/asset/study/blockchain/1/10.png)
[그림 10] 고아(Orphan) 블록의 생성
{: .borderBox}

<br/>
5번 블록으로 인해 고아 블록이 생기게 되는 현상을 “분기가 발생”했다고 하며 분기가 발생하는 경우 메인 체인을 선택하는 것은 작업 증명을 가장 많이 한 체인(블록의 길이가 가장 긴 체인)으로 선택한다.
<br/><br/>
<br/><br/>

### 2. 이더리움
<br/><br/>
이더리움은 2013년 비탈릭 부테린(Vitalik Buterin)이 제안한 후 2015년 7월 세상에 공표한 블록체인 기반의 암호화폐 플랫폼이다(현재도 계속 개발 중이다). 비트코인으로 대표되는 블록체인은 거래 내역을 여러 노드에 동일하게 분산하여 관리하는 것을 기본으로 하고 있지만 비탈릭의 경우에는 단순한 화폐 원장의 기능과 더불어 솔리디티(Solidity)라는 프로그래밍 언어를 통하여 자동으로 실행되는 스마트 컨트랙트(Smart Contract)를 개발할 수 있는 환경을 제공하였다. 이 스마트 컨트랙트를 이용하여 계약서, 공증, 전자 투표 등의 다양한 서비스를 개발하고, 정보를 블록체인 내부에 저장할 수 있는 분산 네트워크 플랫폼이다.
<br/><br/>

#### 2.1 스마트 컨트랙트
<br/><br/>
스마트 컨트랙트는 블록체인 상에서 계약의 당사자들 상호간에 합의된 규칙에 따라 진행될 수 있도록 구현된 소프트웨어이다. 사전에 정의된 규칙에 만족하는 상황이 발생하면 지정해 놓은 계약은 자동적으로 처리되고 모든 처리된 거래 내역은 블록체인상에 기록되어 안전한 거래를 보장한다.
<br/><br/>
현실세계에서는 일반적으로 A와 B의 거래에 있어서 서로 상호 신뢰를 목적으로 계약서를 작성한다. 또한 계약서를 확인하기 위하여 제 삼자(공증이나 거래 중계인 등)가 개입하는 경우가 일반적이다. 이 과정에서 우리는 상당한 수수료를 지불해야 한다. 이제 자동차 계약을 예로 한번 알아보자.
<br/><br/>
![](/asset/study/blockchain/1/11.png)
[그림 11] 고전적 차량 계약
{: .borderBox}
<br/><br/>
[그림 11]은 고전적인 중고차 거래 방식을 표현하고 있다. 차량 판매자는 중고차 딜러에게 차량 매매의사를 밝히고 자신의 차량 정보를 제공한다. 딜러는 해당 차량에 대한 광고를 인터넷 등에 게시하고 구매자를 찾는다. 구매자는 인터넷 정보를 보고 해당 딜러에게 연락하여 구매 의사를 밝힌다. 판매자는 차량과 제반 서류, 자동차 키를 가지고 딜러 사무실로 가고 구매자는 딜러 사무실에서 계약서를 작성한다. 이 때 입금 이전이므로 자동차 키 등을 딜러가 가지고 있고, 구매자로부터 입금이 완료된 것을 확인하며 딜러는 이전 수속을 위한 업무를 진행하고 수수료 등을 양측으로부터 수령한 후 차량을 구매자에게 전달한다. 이 때 판매자와 구매자는 딜러 수수료, 차량 등록 수수료 등을 지불해야 한다. 이 때 구매자가 판매자에게 금액을 송금하고 자신에게 차량이 인도될 때 까지는 딜러를 전적으로 신뢰하여야 하며 불미스러운 일이 발생하여 차량을 인도 받지 못하는 경우도 발생할 수 있는 위험이 있다.
<br/><br/>
이제 이와 같은 거래를 스마트 컨트랙트를 이용하는 경우에 대해 알아보자.
<br/><br/>
![](/asset/study/blockchain/1/12.png)
[그림 12] 스마트 컨트랙트를 이용한 차량 계약
{: .borderBox}
<br/><br/>
먼저 판매자는 자신 차량의 정보와 판매 금액 및 조건을 기반으로 하는 스마트 컨트랙트를 작성하여 블록체인 상에 게시한 후 차량을 스마트 컨트랙트가 동작해서 열 수 있는 곳에 차량을 주차한다. 차량 구매자는 스마트 컨트랙트를 조회(컨트랙트의 내용을 웹이나 앱을 통하여 게시할 수 있다)하여 지정된 계좌로 비용을 송금하는 거래를 발생시킨다. 거래정보를 수신한 노드는 스마트 컨트랙트의 내용에 따라 거래를 요청하였는지 확인한 후 해당 내용을 블록 체인에 기록한다. 구매자는 차고로 가서 차량을 수령한다.
<br/><br/>
이 과정중에 우리는 중간 딜러나 차량 등록 사무소에 서류를 처리하는 행위를 할 필요가 없다. 홍길동이 김철수로부터 1,000만원을 주고 차량을 인도 받았다는 기록이 블록체인상의 모든 노드에 기록되어 있기 때문이다.
<br/><br/>

#### 2.2 가스(Gas) 비용
<br/><br/>
앞서서 차량을 거래하는 데 있어서 서류를 작성하거나 거래를 보증하는 제 3자가 필요하지 않아 비용이 발생하지 않는다고 하였다. 그러나 이러한 거래가 모든 블록체인에 기록되기 위해서는 채굴이라는 과정이 필요하므로 이를 위한 비용이 필요하다. 이 비용을 이더리움에서는 ‘가스비’라고 한다. 이더리움상의 모든 거래는 가스 한계(Gas Limit)와 가스비(Gas Price)가 포함되어 있어야 한다
<br/><br/>

1)	가스 한계(Gas Limit)
<br/><br/>
“가스 한계”는 하나의 트랜젝션을 처리하기 위하여 거래 당사자가 할당한 최대 가스비를 의미한다. 가스 한계를 넘어서는 거래는 즉시 중지되고 거래는 블록체인에 기록되지 않는다. 이 때 중지될 때까지 사용한 비용은 없어진다. 이러한 이유로 가스 한계를 크게 잡아 놓는 것이 좋은데, 너무 크게 된 경우에도 채굴자가 선택하지 못하는 경우가 발생한다. 각각의 블록은 “블록 가스 한계(Block Gas Limit)”를 가지고 있는데 하나의 블록에는 최대 담을 수 있는 가스의 한계값이 존재한다. 채굴자가 트랜젝션을 블록에 추가할 때 블록이 가질 수 있는 가스 한계를 넘어서게 되면 블록에 해당 트랜젝션을 추가할 수 없다.
<br/><br/>
가스 한계값은 단순히 거래에 할당할 수 있는 최대값을 의미하는 것으로 만약 실제 사용한 가스의 양이 이보다 적은 경우에는 실제 사용한 비용만 지출이 된다. 일반적으로 개인 지갑의 코인이나 토큰을 다른 사람의 지갑으로 이동하는 트랜젝션의 경우 21,000가스가 사용된다.
<br/><br/>
스마트 컨트랙트를 수행하면서 발생하는 개별의 코드는 각각 지정한 가스 사용량이 결정되어 있고, 이를 통해 전체적으로 필요한 가스의 양을 결정할 수 있다.
<br/><br/>

2)	Gas Price(Gas Price)
<br/><br/>
스마트 컨트랙트를 수행하기 위하여 실행되는 각각의 코드 단위에 지정된 가스 사용량과 함께 우리는 단위 가스 가격을 설정할 수 있다. 이 가격 설정을 통하여 실제 사용되는 가스비용을 계산할 수 있다.
<br/><br/>
가스 비용을 설정하는 이유는 동일한 거래에 있어서 단위 가스의 비용이 큰 거래를 채굴자들이 먼저 선택하기 때문이다.
<br/><br/>

3)	수수료
<br/><br/>
실제 이더리움상에서 거래에 발생하는 수수료는 “사용한 가스의 총량”과 “단위당 가스 비용”의 곱으로 나타낼 수 있다. 즉, 가스 비용이 높아지게 되면 수수료가 높아지게 되고, 채굴자가 해당 거래를 즉시 선택해서 블록에 추가할 가능성이 높아지게 되는 것이다.
<br/><br/>
<br/><br/>
위의 내용을 자동차와 비교하면 [그림 13]과 같다.
<br/><br/>
![](/asset/study/blockchain/1/13.png)
[그림 13] Gas Limit / Gas Price / Fee
{: .borderBox}
<br/><br/>
탱크 용량이 75L인 택시(가스 자동차)가 손님을 어느 목적지까지 모시고 가기 위해 가스 충전소에 들렸다고 가정해 보자. 운전자는 이 차를 처음 운행하기 때문에 차량의 연비를 모르고, 거리도 정확하게 알 수 없어서 일단 가스탱크를 가득 채우고 출발하기로 마음 먹었다. 이 경우 75L 탱크에 리터당 1,000원씩 계산된 총 75,000원의 가스가 채워지게 된다. 가스를 채운 후 목적지까지 운행을 하고 확인해 보니 실제 사용한 가스는 10L이므로 실제 가스값으로 사용한 것은 10,000원이 되게 되고 차량의 가스 탱크에는 65,000원에 해당하는 가스가 남아 있게 된다.
<br/><br/>
즉, 택시는 최대 75L의 가스를 사용할 수 있지만(가스 한계) 실제 사용한 가스의 양은 10L에 해당하는 10,000원(수수료)만 지불하면 된다. 그리고 안타깝게 75L의 가스를 전부 사용하고도 목적지까지 도착하지 못하면 가스 75L만 사용하고 목적지 도달은 실패하게 되는 것이다(거래의 취소).
<br/><br/>
또한, 급하게 목적지에 가야 하는데 택시가 승차거부를 한다면(요즘은 이런 기사님은 없으시다) 승객은 목적지까지 비용을 더 비싸게(소위 따블) 제시하는 경우가 생긴다. 이런 경우 택시 기사는 정해진 비용보다 더 많이 지불을 할 손님을 태우게 될 것이다. 만약 차량의 연비가 10Km/L라고 가정을 하면 10Km 이동에 필요한 가스비용은 10Km/L * 1L = 1,000원이고 1Km당 100원의 가스가 사용되게 되는 것이다. 그런데 손님이 1Km를 이동하는데 200원의 가스비를 계산해 주겠다고 하하는 것 같은 경우가 되는 것이다. 이와 마찬가지로 채굴자들은 단위 가스비가 높은 거래를 먼저 택하게 되는 것이다.
<br/><br/>
<br/><br/>

### 3. 블록체인을 이용한 서비스
<br/><br/>

블록체인은 중앙 집중화된 데이터를 분산 원장으로 관리하고 스마트 컨트랙트를 이용하여 자동화된 거래를 실행시킬 수 있다는 측면에서 앞으로 많은 산업에 영향을 미치고 발전해 나갈 것이다. [그림 14]는 유명한 컨설팅 그룹에서 제시한 스마트 컨트랙트와 블록체인의 서비스 가능 영역을 나타낸 것이다.
<br/><br/>
![](/asset/study/blockchain/1/14.png)
[그림 14] 스마트 컨트랙트의 활용 예 (출처: PricewaterhouseCoopers)
{: .borderBox}
<br/><br/>
스마트 컨트렉트와 블록체인은 송금과 국가간 거래 등의 금융서비스, 디지털 자산에 대한 권리의 양도 및 보존, 부동산 거래, 물류 등에서 활용될 수 있으며 많은 시도들이 이루어 지고 있다. 그러나 실제 중앙 집권식 데이터 관리에 비해 데이터 정합성을 위한 네트워크 사용에 따른 속도의 저하, 블록 생성 및 합의에 이르기 까지 걸리는 시간 지연 등의 문제등을 극복할 기술적인 발전이 더욱 필요한 상황이다.
